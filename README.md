
## 1\.进程的概念


课本概念：程序的一个执行实例，正在执行的程序等。


内核观点：担当分配系统资源（CPU时间，内存）的实体。


其实：**进程\=内核的相关管理数据结构（task\_struct、页表等）\+程序的代码和数据**


![image](https://img2024.cnblogs.com/blog/3246233/202410/3246233-20241021151515212-231692223.png)


**task\_struct:**是描述进程的结构体，是Linux内核的一种数据结构，它会被装载到RAM(内存)里并且包含着进程的信息。


task\_struct内容分类：



```
1、标示符: 描述本进程的唯一标示符，用来区别其他进程。
2、状态: 任务状态，退出代码，退出信号等。
3、优先级: 相对于其他进程的优先级。
4、程序计数器: 程序中即将被执行的下一条指令的地址。
5、内存指针: 包括程序代码和进程相关数据的指针，还有和其他进程共享的内存块的指针
6、上下文数据: 进程执行时处理器的寄存器中的数据[休学例子，要加图CPU，寄存器]。
7、I／O状态信息: 包括显示的I/O请求,分配给进程的I／O设备和被进程使用的文件列表。
8、记账信息: 可能包括处理器时间总和，使用的时钟数总和，时间限制，记账号等。
9、...

```

## 2\.进程标识符PID


![image](https://img2024.cnblogs.com/blog/3246233/202410/3246233-20241021153026198-618131878.png)


如何查看进程属性：



```
可以用ps ajx，也可以ls /proc(proc是一个存放进程属性的文件)
例：
ps ajx | head -1 && ps ajx |grep myproc
或
ls /proc

```

我们写一个程序


![image](https://img2024.cnblogs.com/blog/3246233/202410/3246233-20241021155401691-542039611.png)


然后使它运行


这时我们查询PID


![image](https://img2024.cnblogs.com/blog/3246233/202410/3246233-20241021155316304-868699165.png)


如果我们关闭进程后再查询，则查不到该进程打印出的PID，因为proc是实时更新的


在程序内获取PID的方法：



```
#include.h> //头文件

getpid();//返回该进程的PID

getppid();//返回该进程的父进程的PID

```

![image](https://img2024.cnblogs.com/blog/3246233/202410/3246233-20241021160255849-1993573533.png)


输出结果


![image](https://img2024.cnblogs.com/blog/3246233/202410/3246233-20241021160352469-128301343.png)


如何杀掉进程:



```
kill -9 +该进程的PID

```

我们写一个死循环的程序，持续打印PID


然后使用kill \-9 命令关闭该进程


![image](https://img2024.cnblogs.com/blog/3246233/202410/3246233-20241021160927852-275936219.png)


## 3\.系统调用创建进程：fork命令初识



```
fork有两个返回值：
如果返回值为0，则为子进程；
返回值大于0，则为父进程；
父子进程代码共享，数据各自开辟空间，私有一份（采用写时拷贝)

```

让我们写个代码来更好的理解一下fork


![image](https://img2024.cnblogs.com/blog/3246233/202410/3246233-20241021163149095-1245353445.png)


运行起来


![image](https://img2024.cnblogs.com/blog/3246233/202410/3246233-20241021163356577-1827073561.png)


我们发现if和else if居然都运行了起来，并且在子进程中对val进行修改，父进程的val值并未改变


由此我们可以知道**父子进程代码共享，且数据是独立的**


## 4\.进程状态


Linux进程状态本质就是用一个变量，取不同的值来表示；


![image](https://img2024.cnblogs.com/blog/3246233/202410/3246233-20241021164510249-99089211.png)


linux进程有以下几个状态


![image](https://img2024.cnblogs.com/blog/3246233/202410/3246233-20241021164341545-380410461.png)


**R状态（运行状态）**


一个进程已经准备就绪，可以随时被系统调度此时就是运行状态；


如果只要一个进程，cpu可以直接分配足够资源执行进程，但是，当有很多的进程被调度后，cpu的资源就不够分配 ，这时每个进程需要去竞争cpu资源，而cpu不可能同时给这么多进程分配资源；这时就要有一个运行队列（runqueue)把PCB组织起来；


进程在这个runqueue中，就是R状态


![image](https://img2024.cnblogs.com/blog/3246233/202410/3246233-20241021164803201-1305308069.png)


**一个进程一旦持有cpu，会一直运行吗？**



```
并不会
一个进程被拿到cpu执行时，并不是等这个进程执行完毕才切换下一个进程。
而是这多个进程在一个时间段内所有的进程都会执行（并发执行），
每个进程执行一个时间片的时间后，就会从cpu上拿下来，切换成下一个进程.(进程切换)
一个时间片通常是10ms左右

```

在查看进程状态时，我们会发现有x状态，也有x\+状态,这是区分进程在前台执行还是在后台执行；



```
./process：进程在前台执行
./process &：进程在后台执行

```

**S、D状态（休眠状态）**


S状态：本质就是等待”资源“就绪，S状态可以中断；


D状态：也是一种休眠状态，不过D状态不可中断；


![image](https://img2024.cnblogs.com/blog/3246233/202410/3246233-20241021165328476-1792983477.png)


一个进程将1GB的数据放置到磁盘中，等待读取，我们知道外设读取速度是比较慢的，这时进程就会等待；但是在等待期间，OS内存严重不足（OS有权限来杀掉进程来释放空间的），这时如果OS看到这个等待的进程，把他杀掉，那么就会造成一个严重的问题：磁盘在读取数据时出现问题，这时它回去找调度它的进程，但是这时候发现进程没有了？？？就会造成这1GB数据的丢失。


如何避免这个问题？


给这个进程设置深度休眠状态，D状态，那么这个进程就不会被OS杀掉，就要等到进程自己醒来。注意D状态用kill也杀不掉，除非重启，有时要断电。


**T、t状态**


T状态：停止进程


t状态：遇到断点的暂停



```
kill -19 PID：暂停进程
kill -18 PID：继续进程

```

**Z状态（僵尸进程）**


Z状态：一个进程执行完毕，且进程也退出了，但是进程占用的资源并没有被完全释放。


让我们看下面的代码


![image](https://img2024.cnblogs.com/blog/3246233/202410/3246233-20241021170351687-1499291622.png)


将程序运行一段时间


子进程执行完后，父进程还在在执行


![image](https://img2024.cnblogs.com/blog/3246233/202410/3246233-20241021170940516-1840724772.png)


此时我们查询该进程的状态


![image](https://img2024.cnblogs.com/blog/3246233/202410/3246233-20241021171153618-1477455062.png)


子进程已经运行完毕，但是需要维持自己的退出信息，在自己进程的task\_struct中会记录自己的退出信息，让父进程来读取，如果父进程没有读取，则该进程会一直存在。


**孤儿进程**



```
孤儿进程：父进程完成，而子进程还在执行；
孤儿进程一般由1号进程（OS本身）进行领养；

```

孤儿进程为什么要被OS领养?



```
要保证子进程被正常回收

```

**X状态（死亡状态）**



```
进程执行完毕，且所占用的资源全部释放；
kill -9 PID
killall 进程名

```

## 5\.进程优先级


什么是优先级？


cpu资源分配的先后顺序，就是指进程的优先权（priority）。



```
本质是指定进程获取某种资源的先后顺序（一个或者多个简单数字）
task_struct进程控制块--->struct----->内部字段---->int prio=xxx
Linux中数字越小，优先级越高；

```

优先级与权限的区别



```
权限：能不能的问题
优先级：已经能了，获取资源的先后问题

```

为什么要有优先级？



```
进程访问的资源（cpu）始终都是有限的。
而系统中进程大部分情况都是比较多的，所以进程之间会有竞争，为了高效完成任务，更合理竞争相关资源，便具有了优先级。

```

**Linux优先级的特点以及查看方式**


PRI ：代表这个进程可被执行的优先级，其值越小越早被执行
NI ：代表这个进程的nice值


![image](https://img2024.cnblogs.com/blog/3246233/202410/3246233-20241021172030814-609581722.png)


PRI:进程优先级


NI:进程优先级的修正数据，**nice**值；



```
新的优先级=优先级+nice值。从而达到对进程优先级动态修改的过程

```

**注意：**nice值是有范围的：\[\-20,19] \-\-\-\-\-40个数字，且优先级都是从80开始的；


如何修改进程的优先级？



```
1.top命令
2.进入top后按 'r' ，输入要修改进程的PID,在输入NI值；

```

  * [1\.进程的概念](#tid-5eFrpP)
* [2\.进程标识符PID](#tid-MAcyKt)
* [3\.系统调用创建进程：fork命令初识](#tid-QABDFC)
* [4\.进程状态](#tid-iEzjj5)
* [5\.进程优先级](#tid-WKDaJD)

   ![](https://github.com/cnblogs_com/blogs/832104/galleries/2424311/t_241003082809_20240928224755.png)    - **本文作者：** [潇湘](https://github.com):[蓝猫机场](https://fenfang.org)
 - **本文链接：** [https://github.com/sunnyhengheng\-cn/p/18489911](https://github.com)
 - **关于博主：** 评论和私信会在第一时间回复。或者[直接私信](https://github.com)我。
 - **版权声明：** 本博客所有文章除特别声明外，均采用 [BY\-NC\-SA](https://github.com "BY-NC-SA") 许可协议。转载请注明出处！
 - **声援博主：** 如果您觉得文章对您有帮助，可以点击文章右下角**【[推荐](javascript:void(0);)】**一下。
     
